\documentclass[a4paper,14pt]{extreport}

\usepackage{bachelor}
\usepackage{algorithmic} % псевдокод

%opening
\begin{document}

\title{Моделирование динамических процессов на регулярных решетках с использованием графических ускорителей}
\author{А. С. Мордвинцев}
\date{\today}


\sloppy  % предпочитать растяжение пробелов заползанию текста на поля

\maketitle

\setcounter{page}{3}

\tableofcontents

\chapter*{Введение}
\addcontentsline{toc}{chapter}{Введение}

В настоящие время, вычислительная техника широко применяется для симуляции разнообразных природных феноменов. Создано множество математическиз моделей, предназначенных для изучения, предсказания или обучения специалистов взаимодействию с различными явлениями. Достаточно часто для постоения качественное вычислительной модели и ее компьтерной реализации требуется найти представление для трехмерных тел со сложной геометрической формой и топологией, которая к тому же может существенно изменяться в процессе проведения вычислительного эксперимента.

Примерами приложений, работающих с такими объектами, являются:
\begin{itemize}
\item симуляторы эррозионных [] или аггрегационных[] процессов,
\item приложения для обработки данных компьютерной томографии,
\item хирургические симуляторы[],
\item программы трехмерного моделирования, реализующие технологии виртуального скульптурирования[].
\end{itemize}

Многие из этих приложений требуют интерактивности с пользоватилем при визуализации и редактировании трехмерной сцены. Так же можно упоминуть игровые приложения, так как в последние несколько лет именно они адаптируют самые свежие разработки в област интерактивной трехмерной графики.

Разработаны различные подходы к машинному представлению трехмерных объектов, и структуры данных, их реализующие. Наиболее распространенным представлением 3D геометрии в современных интерактивных приложениях является полигональное. При таком подходе поверхности объектов аппроксимируются множеством многоугольников (чаше всего треугольниками или четырехугольниками). Этот подход обладает большим количеством достоинств. В частности, современные графические ускорителе позволяют в реальном времени визуализировать сцены, состоящие их миллионов треугольников. Создано огромное количество алгоритмов работы с полигональными 3D моделями. Разработаны структуры данных, поддерживающие эффективные операции перечисления, удаления и добавления примитивов в полигональную сетку.

Несмотря на все приемущества, полигональный подход не лишен недостатков. Например, операции редактирования, изменяющие топологию объектов, и структуры данных, поддерживающие такие операции реализуются как правило достаточно нетривиально и, в случае сложной геометрии объектов, могут быть слишком трудоемкими для интерактивных приложений.

Помимно полигонального, существуют и развиваются другие методы представления трехмерных объектов. Например, воксльное представление и представление облаками точек (point cloud). Воксельное представление 3D объектов часто используется в научной и медицинской графике для представления результатов томографических сканирований или результатов вычислительных экспериментов.

Воксельная сцена представляет собой регулярную трехмерную решетку кубических вокселей. Таким образом, воксели можно считать трехмерным расширением пикселей, составляющих двухмерные растровые изображения. Каждый воксель хранит специфичную для приложения характеристику занимаемого им пространство. Таким характеристиками могут быть: цвет, прозрачность, плотность, температура и т.д. Одинм из недостатков такого подхода являются очень высокие требования к памяти. Объем памяти, требуемой для ханения кубического объема с разрешением $n$ вокселей на каждое измерение, пропорционален $O(n^3)$.

Часто представляют интерес не все воскели занимаемого объектом объема. Например, иногда достаточно хранить только воксели, аппроксимирующие поверхность моделируемого объекта. В этом случае количество хранимых вокселей растет с увеличением разрещения со пропорционально $O(n^D)$, где $D$ --- фрактальная размерность[] исследуемого объекта.

Однако, для хранения только избранных вокселей требуется некая разреженная труктура данных. Такие структуры можно разделить на:
\begin{itemize}
\item иерархические решетки[] и деревья (KD, октарное дерево и т.д.)[],
\item пространственные хэши[],
\item использующие алгоритмы сжатия, например RLE[].
\end{itemize}

Одним из приемуществ воксельного представления трехмерных сцен является сравнительная простота внесения в сцену локальных изменений геометрии и топологии. Оперции редактирования схожи с редактированием двухмерных растровых изображений. Радактирование сцены, упакованной в октарное дерево так же достаточно легко в реализации. Например, операции объединения пересечения или вычитания объектов эффективно выполняются при помощи логических операций на поддеревьями. В данной работ было реализовано разреженное воксельное октарное дерево (SVO)[], интерактивное внечение изменений в которое осуществляется средствам CPU компьютера.

За последние несколько лет резко выросла производительность графических ускорителей (далее \emph{GPU}, \emph{Graphics Processing Unit}) современных компьютеров. Также значительно увеличилась их функциональность. Ранее ускорители могли использовать ограниченное, жестко заданное производителем и стандартами множество методов преобразования координат, расчета освещения, наложения текстур и т.д. Теперь же стало возможным программирование различных этапов построения изображения. Благодаря этому появилось много новых графических эффектов, которые мы видим в современных компьютерных играх. Это новые методы построения теней, процедурная генерация геометрии и текстур, волны на поверхности воды, отражения, преломление лучей и т.д. Ещё одним заметным усовершенствованием \emph{GPU} стала поддержка чисел с плавающей точкой для представления изображений. В графике эта возможность используется в основном для построения \emph{HDR}\footnote{\emph{High dynamic range} (Расширенный динамический диапазон)}-изображений и сохранении промежуточных результатов в многопроходных алгоритмах.

\emph{GPU} изначально были ориентированы на хорошо распараллеленные высокопроизводительные вычисления. К тому же они хорошо распространены и относительно недороги. Из-за этого на них обратили внимание инженеры и ученые, которым необходимо выполнять объемные расчеты для обработки результатов экспериментов, моделирования физических процессов. Оказалось, что дешевые \emph{GPU} иногда даже превосходят по эффективности дорогие специализированные вычислители, заточенные под конкретную задачу. Так же нетрадиционным применением графических ускорителей заинтересовались разработчики игр, применившие их не только для графических эффектов, но и для расчетов игровой физики или искусственного интеллекта в реальном времени.

Так появился термин \emph{GPGPU} (\emph{General-Purpose computation on GPU}), обозначающий «непрофильное» использование \emph{GPU} для решения слабо связанных традиционной интерактивной графикой задач. Ускоритель в данном случае используется в качестве потокового вычислителя с большим количеством параллельно работающих процессоров.

Приложение может использовать вычислительные мощности \emph{GPU} различными способами. Традиционным является способ, когда при реализации алгоритма программист оперирует непосредственно с графическим \emph{API} и описывает отдельные шаги алгоритма виде небольших программных шейдеров. Однако, этот подход не очень удобен из-за того, что программисту нужно изучать особенности графических \emph{API} (\emph{OpenGL} или \emph{Direct3D}) и специальные языки, которые в них используются для написания кода, выполняющегося на видеокарте (\emph{GLSL}, \emph{Cg}\cite{cg:2005}, \emph{HLSL}).

Для того, чтобы упростить разработку \emph{GPGPU}-приложений, было создано несколько библиотек, которые скрывали от пользователя тонкости работы с \emph{GPU}, выставляя наружу интерфейсы для выполнения различных операций над массивами данных, например, операций линейной алгебры, таких как умножение матриц или решение систем уравнений. Примерами таких библиотек являются \emph{BrookGPU}\footnote{\url{http://graphics.stanford.edu/projects/brookgpu/}} и \emph{RapidMind}\footnote{\url{http://www.rapidmind.net}}.

Производители видеокарт, заметив интерес к необычным применениям своей продукции, создали свои средства для создания \emph{GPGPU}-приложений. Одной из первых стала доступной технология компании \emph{NVIDIA} \emph{CUDA}\footnote{\emph{Compute Unified Device Architecture}}. Затем появились схожие с ней технологии \emph{OpenCL} и \emph{DirectCompute}, поддерживаемые различными производителями. Использование этих средств позволяет снять некоторые принципиальные ограничения, накладываемые графическими \emph{API} и более гибко и эффективно использовать ресурсы видеокарты.

В данной работе для ускорения некоторых вычислений используется технология CUDA компании NVIDIA. В частности, она испльзуется для визуализации сцены, пердставленной октарным воксельным деревом, при помощи обратной трассировки лучей.

В работе рассмотрены некоторые особенности, которые следует учитывать при переносе вычислений на GPU при помощи технологии CUDA. В частности, выполнена оцненка эффективности работы встроенного в планировщика заданий

\chapter{Воксельная графика}

В данной главе рассмотрены различные подходы к компьтерному представлению трехмерных сцен. Так дается обзор технологии CUDA и ее приложений к ускорению опреций воксельной графики. Так же рассметрена полип-ориентированная модель роста коралла, ставшая полем для экспериментов и источником сложной геометрии при выпонении данной работы.

\section{Представление трехмерных сцен}
\subsection{Полигональное}

Полигональное представление трехмерных объектов является на данный момент наиболее распространенным подходом в интерактивной трехмерной графике. При этом подходе, поверхность моделируемого объекта аппроксимируется многоугольными примитивами. Такой подход обладает следующими достоинствами:

\begin{itemize}
\item давно известный и широко применяемый метод, множество публикаций, библиотек и приложений для работы с полигональным представлением;
\item современые графические ускорилели способны визуализировать сцены из миллионов треугольников со скоростью, приемлимой для интерактивных приложений;
\item простота геометрических трансформаций и деформации объектов.
\end{itemize}

++ обзор операций, ссылки

++ различные структуры данных

++ список верщин, список индексов граней

++ half-egde

++ недостатки, заключение
Объем данных зависит от сложности поверхности объекта (количества вершин и полигонов).

\subsection{Массив вокселей}

++ объемный массив

++ воксель-пиксель

++ медицина, научная графика

++ визуализация

++ объем памяти, недостатки

\subsection{Разреженные структуры данных: воксельное октарное дерево}

Часто при решении некоторой задачи интерес представляет на весь объем воксельной сцены, а только некоторая его область. Например, это может быть граница моделируемого объекта. В этом случае колличество вокелей, необходимых для представления объекта пропорционально $S/h^2$, где $S$ -- площадь поверхности объекта, а $h$ -- линейный размер вокселя. Следует заметить, что исследуемые объекты часто могут иметь фрактальную сруктуру, площадь которой может быть не определена. В этом случае можно рассматривать площадь некой аппроксимации, отбрасывающей детали объекта размером меньше $h$. Площадь такой поверхности можно оценить как $S \in O((l/ h)^D)$, где $l$ -- линейный размер объекта, $D$ -- фрактальная размерность поверхности. С более формальными рассуждениями свойствах фрактальных объектов можно ознакомиться в книге [].
Таким образом, если фрактальная размерность поверхности объекта близка к двум, можно добиться значительного сокращения объема памяти занимаемой сценой, по сравнению с представлением ввиде неупакованного трехмерного массива вокселей.

Для компактного хранения подмножества вокселей сцены требуется некая разреженная структура данных. Примерами таких структура являются:

\begin{itemize}
\item пространственный хэш [],
\item RLE-упакованный массив[],
\item иерархия вложенных решеток[],
\item октарное дерево[], 
\item и т.д.
\end{itemize}

В данной работе рассматривается хранение и визуализация сцены, представленной разреженным воксельным октарным деревом (sparse voxel octree, SVO)[]. 

++ октарное дерево представляет собой ...

\begin{figure}[h]
  \begin{center}
    \subfigure{}{\includegraphics[height=8cm]{tree-heir.pdf}} 
    \subfigure{}{\includegraphics[height=8cm]{tree-rays.pdf}}
  \end{center}
  \caption{Разрезенное октарное дерево}
  \label{fig:svo}
\end{figure}

++ Для редактирования сцены, представленной воксельным октарным деревом в данной работе применяются логические операции над поддеревяьми.

\section{Визуализация воксельных объектов}

Существуют различные подходы к визуализации воксльных сцен.  С некоторыми из них можно ознакомится в работах[]. В данной работе используется подход, основанный на обратной трассирове лучей.

Идея метода заключается в трассировке от наблюдателя одного или нескольких лучей для каждого пикселя генерируемого изображения. В процессе трассировки отслеживаются столкновения луча с объектами сцены и, на основе их свойств (таких как цвет, прозрачность, освещенность и т.д.)  расчитывается их вклад в финальный цвет пикселя.

\subsection{Объемная визуализация}

В данной работе реализавано два алгоритма визуализации воксельной сцен, работающие с двумя разными из представлениями. Первый из них, реализация которого описана в главе ++, используется для отладочной визуализации поля концентрации планктона для модели просто коралла, описанной в главе ++. Этот метод базируется на методе объемного рендеринга (volume rendering). Суть метода заключается в визуализации некоторого трехмерного скаларного поля $v$ ввиде "облака". Скаларное поле представлено трехмерным массовом, хранящим значения $v$ в узлах регуларной решетки. Для получения значения поля в промежуточных между узнами точках пространства используется трилинейная интеполяция. Для визуализации различных диапазонов значений скалярного поля различными цветами, а так же для выделения только интересующего диапазона используют функицию переноса $T(v) = (q_r, q_g, q_g, \kappa)$, отображающую скалярное поле в интенсивность излучения трех цветовых компонент и коэффициент поглащения.

В процессе рендеринга изображения для определения цвета каждого писеля решается уравнение переноса света вдоль луча, параметризованного переменной $t$: 
$$ I(t) = I(t_0)\tau(t_0, t) + \int_{t_0}^t q(s)\tau(s, t) ds $$
$$ \tau(t_1, t_2) = e^{-\int_{t_1}^{t_2} \kappa(s)ds} $$
где $I(t)=(r, g, b)$ -- интенсивность светового потока в направление наблюдателя в точке луча. Интенсивность расчитывается для трех цветовых компонент $r$, $b$, $g$ -- красного, зеленого и синего. $\tau(t_1, t_2)$ обозначает прозрачность участка луча между точками $t_1$ и $t_2$. $\kappa(t)$ обозначает коффициент поглащения света, а $q(t)$ -- коэффициент излучения.

Для вычисления интенсивности путь луча через сцену разбивается на $n$  сегментов, раздеяемых точками ${t_0, t_1, ..., t_n}$. Количество шагов подбирается так, чтобы были как можно менее заметный артефакты визуализации, возникающие из-за недостаточно точного расчета светового потока, но производительность оставалась приемлимой.

Введем обозначения $$ \theta_k = \tau(t_{k-1}, t_k), \;\;\; b_k = \int_{t_{k-1}}^{t_k}\! q(s)\tau(s, t_k) ds, $$ тогда $$ I(t_n) = I(t_{n-1})\theta_n + b_n = (I(t_{n-2})\theta_{n-1} + b_{n-1})\theta_n + b_n = ...$$ 
$$ = \sum_{k=0}^n b_k \prod_{j=k+1}^n \theta_j, \;\;\; b_0 = I(t_0).$$

Интенсивность луча света, проходящего от внешней границы сцены к наблюдателю можно расчитать при помощи следующего алгоритма:

\begin{algorithmic}
\STATE $intensity = b_0$
\FOR{$k = 1; k \le n; k = k + 1$} 
\STATE $intensity = \theta_k intensity + b_k$
\ENDFOR
\end{algorithmic}

Однако, часто удобнее трассировать луч не к наблюдателю, а от него. Это позволяет, например, отбросить первые члены суммы, вклад которых в результат оказывается меньше некоторого порога, что может существенно улучшить производительность, для сцен, содержащих много непрозрачных участков.

\begin{algorithmic}
\STATE $intensity = b_n$
\STATE $transparency = \theta_n$
\FOR{$k = n-1; k \ge 0; k = k - 1$} 
\STATE $intensity = intensity + b_k transparency$
\STATE $transparency = \theta_k transparency$
\ENDFOR
\end{algorithmic}

Так же обратный порядок обхода удобен при ингерации полигональной и объемной графки.

С деталями реализации данного метода с использованием GPU и результатами работы можно ознакомиться в разделе ++

\subsection{Освещение воксельной поверхности}

В данной работе рассматривается и другой метод визуализации воксельных объектов при помощи трассировки лучей. Этот метод работает со сценой, в которой все пространство делится на абсолютно прозрачные области между объектами и абсольтно непрозрачные границы объектов. В этом случае для определения цвета пикселя требуется найти только первое пересечение луча, ведущего от наблюдателя, с поверхностью объекта. 

В реализацию данного метода было рещено добавить возможность освещения поверхности точечными источниками света. Использована модель затенения Фонга[], которой, для расчета диффузной компоненты освещения и зеркального блика требуется информация о векторе нормали к поверхности в освещаемой точке. Поэтому каждый воксель поверхности, в использованном представлении сцены, помимо информации о цвете, хранит также нормаль к поверхности. Интенсивность освещенности в данной модели расчитывается как $$ I_p = k_a i_a + \sum_\mathrm{m \; \in \; lights} (k_d (L_m \cdot N) i_d + k_s (R_m \cdot V)^{\alpha}i_s $$
где  $k_a, k_d, k_s$ -- коэффициенты интенсивности амбиентной, диффузной и спектральной компонент освещения для объекта, $k_a, k_d, k_s$, $N$ -- нормаль к поверхности, $L$ -- направление на источник света, $V$ -- направление на наблюдателя, $R$ -- направление отраженного луча, а $\alpha$ -- коэффициент, определяющий резкость бликов.

Так как все пространство мезду границами и внутри объектов игнорируется, для компартного хранения пограничных вокселей используется разреженное октарное воксельное дерево (SVO) ++.

\section{Полип-ориентированная модель роста коралла}
В качестве источника сложной геометрии, а так же для экспериментов с реализацией алгоритмов над воксельными массивами и вокселизацией полигональных сеток, в рамках данной работы была реализована \emph{полип-ориентированниая модель роста коралла}[]. 

Пример коралла, сгенерированного при помощи данной модели можно найти на рис.++. В данной модели поверхность скелета коралла представляется сеткой треугольнгиков. Однако, на каждой итерации алгоритма выполяенся ее вокселизация на регулярную решетку.

++ этапы итерации

%\include{cuda}

\section{Использование GPU для ускорения операций с воксельными объектами}

Решение многих задач воксельной графики требует выполнение одной и той же опреции над большим количеством однородных элементов данных. Такие вычисления обычно хорошо параллелятся и ложатся на вычислительную архитектуру графических ускорителей последних поколений.

В данной работе GPU ускорение при помощи технологий CUDA и OpenGL/Cg используется для задач:
\begin{itemize}
\item вокселизаця полигональной сетки на регулярную решетку в модели роста коралла, ++
\item расчет диффузии планктона и его поглащения полипами, ++
\item совместная визуализация полигонального скелета коралла (растеризация) и облака пространственного распределения планктона (трассировка лучей), ++
\item визуализация вокселизированной поверхности, упакованной в октарное дерево, методом обратной трассировки лучей.
\end{itemize}

\subsection{Вокселизация с тспользованием растеризатора GPU}
В рамках реализации модели роста коралла[] был реализован однопроходный алгоритм вокселизации, описанный в работе[]. Этот алгоритм полагается на использование аппаратной растерицазии полигонов. Данная фугкциональность видеокарт не доступна при использовании CUDA, поэтому алгоритм реализован при помощи OpenGL API с использованием языка шейдеров Cg.

Алгоритм получает на вход треугольную сетку. Выходом алгоритма является массив биттов, соответствующих узлам регулярной трехмерной решетки, значения которых которых равняются единице, если узел лежит внутри объема, оганиченного сеткой, и нулю в противном случае. Для корректной работы алгоритма понятия "внутри" и "снаружи" должны иметь смысл, тоесть поверхность не должна иметь разрывов и самопересечений. Параметры сетки, такие как разрешение решетки и координаты вокселизируемого объема задаются перед запуском алгоритма. Разрешение решетки ограничивается объемом памяти и некоторыми характеристиками видеокарты, о которых подет речь ниже.

Для начало кратко опишем используемые при вокселизации возможности современных GPU. На рис.\ref{fig:gl_pipeline} показамы основные стадии обработки данных, выполняемые GPU во время ренеринга изображения.

\begin{figure}[ht]
\center
\includegraphics[width=120mm]{gl_pipeline}
\caption{Основные узла конвейера OpenGL API}
\label{fig:gl_pipeline}
\end{figure}

Графический ускоритель проэцирует поступающие вершины на экран при помощи \emph{вершинного шейдера} (\emph{vertex shader}). Затем, на этих вершинах строятся примитивы, которые затем растеризуются в сетку \emph{фрагментов}. В приложениии вокселизации фрагменты считаются эвивалентными пикселям, хотя, строго говоря, это не всегда так. При использовании техники supersampling[] для сокрытия ступенчатого эффекта (aliasing) для каждого пикселя финального изображения может вычисляться несколько фрагментов.

После вычисоения фрагментным шейдером цвета и глубины каждого фрагмента, выполняется отсечение скрытых фрагментов, при помощи z-буфера и смешивание (blending) нового значения для данного фрагмента с содержимым буфера кадра (framebuffer).

Перечислим особенности, имеющиеся в современных GPU, которые позволяют использовать графичский конвейер для эффективной однопроходной вокселизации полигональных сеток.

\begin{itemize}
\item Представление каждого из 4-х (r, g, b, alpha) цветовых каналов изображения в буфере кадра 32-битными целами числами. Таким образом фрагменый шейдер может записть до $32 \cdot 4 = 128$ бит данных в каждый \emph{render target} буфера кадра.
\item Использование до 8 \emph{render target}'ов одновременно. Это позволяет увеличить количество бит информации, возвращаемых фрагментным шейдером до $128 \cdot 8 = 1024$ бит.
\item Возможность использования битовых операций, в частности \texttt{xor}, при блендинге пикселей в буфер кадра.
\item Отключение использования буфера глубины, благодаря чему возможно поподание в буфер кадра фрагментов всех примитивов, не зависомо от их видимости.
\end{itemize}

Используемый метод позволяет производить вокселизацию в решетку, одно измерение которой (назовем его глубиной) не превышает 1024. Разрешение двух других измерений определяется объемом доступной памяти. В модели коралла использовалась решетка размером $256^3$, которая требовала $256^3 = 2^{24}$ бит $ = 2$ мб. Так же проводились экспериметны в решеткой $1024^3$, которая требовала 128 мб памяти видеоускорителя.

Алгоритм воселизации можно описать следующей последовательность шагов.

\begin{enumerate}
\item Привести OpenGL в нужное сотояние:
\begin{itemize}
\item Установить специально подротовленный framebuffer в качестве выходного.
\item Настроить ортогональную проекцию интересующего участка сцены в этот буфер.
\item Отключить использоваие z-буффера.
\item Установить описанный ниже фражментный шейдер.
\item Включить \texttt{xor} в качестве логической опрерации при записи фрагментов в буфер кадра.
\end{itemize}
\item При необходимости установить значения всех битов буфера кадра в 0.
\item Отрисовать все треугольники сцены один раз в произвольном порядке.
\item Использовать полученую вокселизацию, обращаясь к буферу кадра, как к текстуре.
\end{enumerate}

Основная тонкость алгоритма заклютается в используемой фрагментной программе. С ее исходныйм текстом можно ознакомиться в приложении ++. Результатом работы этой программы является столбец из 1024 бит, соответствующий одному столбцу объема. Программа построена таким образом, что в возвращаемом столбце все биты, соответствующие узлам решетки, лежащим выше растеризуемого примитива устанослены в 1, а все лежащие ниже равняются 0. Таким образом, операция \texttt{xor} инвертирует состояние всех битов буфера кадра, лежащих выше растеризуемого примитива. После расеризации всех примитивов получается, что биты, соответствующие узлам, лежащие за границей объекта, инвертируются четное число раз, и раняются 0, а биты, соответствующие внитренним узлам решетки инвертируются нечетное число раз, и становятся равными 1.

Данный алгоритм отличается учень эффективным использованием аппаратных ресурсов видеокатры и обеспечивает высокую производительность, делающую его пригодным для растеризации объектов в решетки с высоким разрещением в реальном времени. Авторы утерждают, что время вокселизации объекта, состоящего из примерно 256 тысяч треугольников в решетку с разрешением $1024^3$ занимает порядка 10 мс. Оценки производительности, полученные на схожем оборудовании при выполнении данной работы сравнимы с авторскими, хотя немного уступают им. Возможно, это связано с недостаточно оптимизированной реализацией алгоритма или особенностями методики проведения измерений.

\section{Трассировка лучей в октарном дереве}

Одной из главных частей данной работы является реализация интерактивной обратной трассировки лучей в октарном воксельном дереве. Идея использования октарных деревьев для ускорения трассировки лучей известна уже давно[]. В данной работе рассматривается реализация алгоримта трассировки при помощи современных GPU и технологии CUDA.

В этом разделе будут описаны идеи, которые легли в основу реализации трассаровщика лучей на GPU. Сама же реализация, с указанием специфичных для конкретной вычислительной архитектуы деталей будет описана в разделе ++.

Пусть весь объем сцены, упаковынный в октарное дерево лежит в единичном кубе, ребра




\chapter{Особенности реализации воксельных алгоритмов на GPU}
\section{CPU-GPU реализация Полип-ориентированной модели роста коралла}
\subsection{Архитектура приложения}
\subsection{Вокселизация полигональной сетки}
\subsection{Расчет диффузии}
\subsection{Обновление полигональной сетки}
\section{Визуализация воксельного октарного дерева методом обратной трассировки лучей}
\subsection{Архитектура приложения}

\chapter{Исследование эффективности GPU-операций над воксельными объектами}
\section{Анализ производетельности этапов модели роста кораллов}
\section{Анализ производетельности трассировки лучей в воксельном октарном дереве}
\subsection{Особенности работы с памятью и их влияние на производительность}
\subsection{Балансировка вычислительной нагрузки}

\chapter*{Заключение}
\addcontentsline{toc}{chapter}{Заключение}

\addcontentsline{toc}{chapter}{Литература}
\begin{thebibliography}{99}

\end{thebibliography}



%\include{intro}

%\include{cuda}
%\include{coral}
%\include{svo_trace}
%\include{voxelization}


%\appendix
%\renewcommand{\appendixname}{Приложение}

\include{bibl}


\end{document}
